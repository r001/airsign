#!/usr/bin/env node
const QRCode = require('qrcode')
const decode = require('qr-encoding').decode
const fs = require('fs')
const inquirer = require('inquirer')
const keythereum = require("keythereum")
const sigUtil = require('@metamask/eth-sig-util')
const {DataType, EthSignRequest, ETHSignature, DataItem} = require('@keystonehq/bc-ur-registry-eth')
const {URRegistryDecoder, CryptoKeypath, PathComponent} = require('@keystonehq/bc-ur-registry-eth')
const {Transaction, FeeMarketEIP1559Transaction} = require('@ethereumjs/tx')
const {stripHexPrefix, toBuffer, toRpcSig} = require('@ethereumjs/util')
const {keccak256} = require('ethereum-cryptography') 
const rlp = require('@ethereumjs/rlp')
const {promisify} = require('es6-promisify')
const readdir = promisify(fs.readdir)

var api
const arg = process.argv[2]

const ai = '/data/data/com.termux/files/home/airsign/'

;(async () => {

	if (!arg) {
		// fixed bug termux hang during loading
		api = require('termux')
	}


	if (arg) {
		try {
			await sign(arg)
		} catch (e) {
			if (!arg.match(/-/)) {
				console.log(`Could not decode.`)
			}
			// `airsign -` called

			let answers = inquirer.prompt([
				{
					type: 'input',
					name: 'qr',
					message: 'Signable:',
					validate (value) {
						try {
							decode(value)
							return true
						} catch (e) {
							return 'Should be something like: ETHS:/T001011....'
						}
					},
					filter: String,
				}
			])

			await sign(answers.qr)
		}
	} else if (api.hasTermux) {
		var decoder = new URRegistryDecoder()
		var needMoreData = true
		var ur

		while (needMoreData) {
			ur = await api.clipboardGet().run()
			needMoreData = decoder.receivePart(ur)
			await sleep(500)
		}
		var ethSignRequest = EthSignRequest.fromCBOR(decoder.resultUR().decodeCBOR())
		await sign(ethSignRequest)
	}

	process.exit(0)
})()

async function sign (ethSignReq) {
	// TODO: erase line below, and change ethSignReq to ethSignRequest above
	let ethSignRequest = EthSignRequest.fromCBOR(ethSignReq.toCBOR())
	var keyStore = ai + '.ethereum/keystore/'
	let parentFingerprint = Buffer.from('12345678', 'hex')

	let files = await readdir(keyStore) 

	let	fromJson = files
		.map(file => {
			try {
				return JSON.parse(fs.readFileSync(keyStore + file))
			} catch (e) {
				return {address: ''}	
			}
		})
		.find(json => 
			getFakeDerivePath(json.address, parentFingerprint) === 
			ethSignRequest.getDerivationPath()
		)

	if (!fromJson) throw new Error('Address not found for: ' + ethSignRequest.getDerivationPath().toString())

	let answer = await inquirer.prompt([
		{
			type: 'password',
			name: 'pw',
			message: 'Password:',
			mask: '*',
		}
	])

	var privateKey = keythereum.recover(answer.pw, fromJson)
	answer.pw = null
	const EIP_1599_TRANSACTION_TYPE = 2
	const EIP_1599_TRANSACTION_TYPE_BUFFER = Buffer.from(EIP_1599_TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')
	let tx, data, version, type, signature
	let rlpEncoded = ethSignRequest.getSignData()
	switch (ethSignRequest.getDataType()) {
		case DataType.typedTransaction:
			type = rlpEncoded.subarray(0, 1)

			if (!type.equals(EIP_1599_TRANSACTION_TYPE_BUFFER)) {
				throw new Error('Unknown transaction type')
			}
			tx = FeeMarketEIP1559Transaction.fromSerializedTx(rlpEncoded)
			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r === '' ? '0x' : tx.r),
				toBuffer(tx.s === '' ? '0x' : tx.s),
				tx.common.chainId
			)

			break
		case DataType.transaction:
			tx = Transaction.fromSerializedTx(rlpEncoded)
			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r === '' ? '0x' : tx.r),
				toBuffer(tx.s === '' ? '0x' : tx.s),
				tx.common.chainId
			)

			break
		case DataType.personalMessage:
			signature = sigUtil.personalSign({
				privateKey,
				data: '0x' + stripHexPrefix(ethSignRequest.getSignData().toString('hex')),
			})

			break
		case DataType.typedData:
			[version, data] = rlp.decode(ethSignRequest.getSignData())
			version = `V${version.toString('utf8')}`
			data = JSON.parse(data.toString('utf8'))

			signature = sigUtil.signTypedData({
				privateKey,
				data,
				version,
			})

			break
		default:
			throw new Error('Type not supported: ' + ethSignRequest.getDataType())
	}

	privateKey = null	
	const types = ['terminal', 'utf8', 'svg']	
	let ur = ETHSignature.fromDataItem(new DataItem(signature)).toCBOR().toUREncoder(500)
	let urPart = ur.nextPart()

	types.forEach(type => {
		QRCode.toString(urPart, {type}, (err, str) => {
			if (err) throw new Error(err)
			fs.writeFileSync(`qr.${type}`, Buffer.from(str))
		})
	})

	// eslint-disable-next-line no-constant-condition
	while (true) {
		QRCode.toString(urPart, {terminal: "terminal"}, (err, str) => {
			if (err) throw new Error(err)
			console.log(str)
			console.log(urPart)
			require('child_process').spawnSync("read _ ", {shell: true, stdio: [0, 1, 2]});
		})
	}
}

function sleep (ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}

function getFakeDerivePath (address, parentFingerprintBuffer) {
	let addressHash = keccak256(Uint8Array.from(Buffer.from(address, 'hex')))
	return (new CryptoKeypath (
		[0, 1, 2, 3].map(index => new PathComponent({index: addressHash[index], hardened:true})),
		parentFingerprintBuffer
	)).getPath()
}


