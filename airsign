#!/usr/bin/env node
const QRCode = require('qrcode')
const decode = require('qr-encoding').decode
const fs = require('fs')
const inquirer = require('inquirer')
const keythereum = require("keythereum")
const sigUtil = require('@metamask/eth-sig-util')
const {DataType, EthSignRequest} = require('@keystonehq/bc-ur-registry-eth')
const {URRegistryDecoder} = require('@keystonehq/bc-ur-registry-eth')
const {Common} = require('@ethereumjs/common')
const {Transaction, FeeMarketEIP1559Transaction} = require('@ethereumjs/tx')
const {stripHexPrefix, toBuffer, toRpcSig} = require('@ethereumjs/util')
var api
const arg = process.argv[2]

if (!arg) {
	// fixed bug termux hang during loading
	api = require('termux')
}


const ai = '/data/data/com.termux/files/home/airsign/'

if (arg) {
	try {
		// `airsign ETHS:/T101105...` called
		sign(arg)
	} catch (e) {
		if (!arg.match(/-/)) {
			console.log(`Could not decode.`)
		}
		// `airsign -` called

		inquirer.prompt([
			{
				type: 'input',
				name: 'qr',
				message: 'Signable:',
				validate (value) {
					try {
						decode(value)
						return true
					} catch (e) {
						return 'Should be something like: ETHS:/T001011....'
					}
				},
				filter: String,
			}
		]).then((answers) => {
			sign(answers.qr)
		})

	}
} else if (api.hasTermux) {
	var decoder = new URRegistryDecoder()
	var needMoreData = true
	var ur

	(async () => {
		while (needMoreData) {
			ur = await api.clipboardGet().run()
			needMoreData = decoder.receivePart(ur)
			await sleep(500)
		}
		var ethSignRequest = EthSignRequest.fromCBOR(decoder.resultUR().decodeCBOR())
		sign(ethSignRequest)
	})()
}

function sleep (ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}


function sign (ethSignReq) {
	let ethSignRequest = EthSignRequest.fromCBOR(ethSignReq.toCBOR())
	// TODO: start from here!!!!!
	var sigParams = decode(text)
	var fromJson, signature, common
	var keyStore = ai + '.ethereum/keystore/'
	var re = new RegExp(sigParams.from_part.toLowerCase())

	fs.readdir(keyStore, (err, files) => {
		if (err) {
			throw new Error(err.stack);
		}

		fromJson = files
			.map(file => {
				try {
					return JSON.parse(fs.readFileSync(keyStore + file))
				} catch (e) {
					return {address: ''}	
				}
			})
			.find(json => 
				json.address
				.replace(/^/, '0x')
				.toLowerCase()
				.match(re)
			)

		if (!fromJson) throw new Error('Address not found for: ' + sigParams.from_part)

		inquirer.prompt([
			{
				type: 'password',
				name: 'pw',
				message: 'Password:',
				mask: '*',
			}
		]).then( (answer) => {
			var privateKey = keythereum.recover(answer.pw, fromJson)
			answer.pw = null
			const EIP_1599_TRANSACTION_TYPE = 2
			const EIP_1599_TRANSACTION_TYPE_BUFFER = Buffer.from(EIP_1599_TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')
			let tx, rlpTx, EIP_1599
			switch (sigParams.type) {
				case 'sign_transaction':
					rlpTx = ethSignRequest.getSignData()
					EIP_1599 = rlpTx.subarray(0, 1).equals(EIP_1599_TRANSACTION_TYPE_BUFFER)
					if (EIP_1599) {
						tx = FeeMarketEIP1559Transaction.fromSerializedTx(rlpTx)
					} else {
						tx = Transaction.fromSerializedTx(rlpTx)
					}
					tx = tx.sign(privateKey)

					signature = toRpcSig(
						tx.v,
						toBuffer(tx.r === '' ? '0x' : tx.r),
						toBuffer(tx.s === '' ? '0x' : tx.s),
						BigInt(rawTx.chainId)
					)

					break
				case 'sign_message':
					signature = sigUtil.personalSign({
						privateKey,
						data: '0x' + stripHexPrefix(sigParams.payload),
					})

					break
				case 'sign_personal_message':
					signature = sigUtil.personalSign({
						privateKey,
						data: '0x' + stripHexPrefix(sigParams.payload),
					})

					break
				case 'sign_typed_data':
					signature = sigUtil.signTypedData({
						privateKey,
						data: JSON.parse(stripHexPrefix(sigParams.payload)),
						version: sigParams.version,
					})

					break
				default:
					throw new Error('Not supported: ' + sigParams.type)
			}

			privateKey = null	
			const types = ['terminal', 'utf8', 'svg']	

			types.forEach(type => {
				QRCode.toString(signature, {type}, (err, str) => {
					if (err) throw new Error(err)
					fs.writeFileSync(`qr.${type}`, Buffer.from(str))
				})
			})

			var type = 'terminal'
			while (type) {
				QRCode.toString(signature, {type}, (err, str) => {
					if (err) throw new Error(err)
					console.log(str)
					console.log(signature)

					require('child_process').spawnSync("read _ ", {shell: true, stdio: [0, 1, 2]});
				})
			}
		})	
			.catch((error) => {
				throw new Error( `Inquirer failure: ${error.stack}`)
			})
	})
}
