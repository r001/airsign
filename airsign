#!/usr/bin/env node
const QRCode = require('qrcode')
const fs = require('fs')
const inquirer = require('inquirer')
const keythereum = require("keythereum")
const sigUtil = require('@metamask/eth-sig-util')
const {DataType, EthSignRequest, ETHSignature, DataItem, CryptoKeypath, PathComponent} = require('@keystonehq/bc-ur-registry-eth')
const {URDecoder} = require('@ngraveio/bc-ur')
const {Common, Chain, Hardfork} = require('@ethereumjs/common')
const {Transaction, FeeMarketEIP1559Transaction} = require('@ethereumjs/tx')
const {stripHexPrefix, toBuffer, toRpcSig} = require('@ethereumjs/util')
const {keccak256} = require('ethereum-cryptography/keccak') 
const rlp = require('@ethereumjs/rlp')
const {promisify} = require('es6-promisify')
const readdir = promisify(fs.readdir)

var api
const arg = process.argv[2]

const ai = '/data/data/com.termux/files/home/airsign/'

;(async () => {
try {
	if (!arg) {
		// fixed bug termux hang during loading
		api = require('termux')
	}


	if (arg) {
		try {
			await sign(arg)
		} catch (e) {
			if (!arg.match(/-/)) {
				console.log(`Could not decode.`)
			}
			// `airsign -` called

			let answers = inquirer.prompt([
				{
					type: 'input',
					name: 'qr',
					message: 'Signable:',
					validate (value) {
						try {
							var decoder = new URDecoder()
							decoder.receivePart(value)
							return true
						} catch (e) {
							return 'Should be something like: ur:eth-sign-request/...'
						}
					},
					filter: String,
				}
			])

			await sign(answers.qr)
		}
	} else if (api.hasTermux) {
		var decoder = new URDecoder()
		var ur

		console.log(`Receiving data from clipboard... (press Ctrl+C to cancel)`)
		while (!decoder.isComplete()) {
			ur = await api.clipboardGet().run()
			console.log(ur)
			decoder.receivePart(ur)
			await sleep(1000)
		}

		if (decoder.isSuccess()) {
			var ethSignRequest = EthSignRequest.fromCBOR(decoder.resultUR().cbor)
			console.log(`Received and decoded request successfully`)

			await sign(ethSignRequest)
		} else {
			throw new Error('Could not decode.')
		}
	}

	process.exit(0)
} catch (e) {
	console.error(e.stack)
	process.exit(1)
}
})()

async function sign (ethSignRequest) {
	var keyStore = ai + '.ethereum/keystore/'
	let parentFingerprint = Buffer.from('12345678', 'hex')

	let files = await readdir(keyStore) 

	let	fromJson = files
		.map(file => {
			try {
				return JSON.parse(fs.readFileSync(keyStore + file))
			} catch (e) {
				return {address: ''}	
			}
		})
		.find(json => 
			(!!json.address) && getFakeDerivePath(json.address, parentFingerprint) === 
			ethSignRequest.getDerivationPath()
		)

	if (!fromJson) throw new Error('Address not found for: ' + ethSignRequest.getDerivationPath().toString())

	let answer = await inquirer.prompt([
		{
			type: 'password',
			name: 'pw',
			message: 'Password:',
			mask: '*',
		}
	])

	var privateKey = keythereum.recover(answer.pw, fromJson)
	answer.pw = null
	const EIP_1599_TRANSACTION_TYPE = 2
	const EIP_1599_TRANSACTION_TYPE_BUFFER = Buffer.from(EIP_1599_TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')
	let tx, data, version, type, signature, rlpDecoded, txData, common, chainId
	let rlpEncoded = ethSignRequest.getSignData()
	switch (ethSignRequest.getDataType()) {
		case DataType.typedTransaction:
			type = rlpEncoded.subarray(0, 1)

			if (!type.equals(EIP_1599_TRANSACTION_TYPE_BUFFER)) {
				throw new Error(`Unknown transaction type ${type.toString('hex')} <> ${EIP_1599_TRANSACTION_TYPE_BUFFER.toString('hex')}`)
			}

			tx = FeeMarketEIP1559Transaction.fromSerializedTx(rlpEncoded)
			console.log('EIP-1559 transaction detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`To: ${tx.to.toString()}`)
			console.log(`ChainId: ${tx.chainId}`)
			console.log(`Nonce: ${tx.nonce}`)
			console.log(`Max Priority Fee Per Gas: ${tx.maxPriorityFeePerGas}`)
			console.log(`Max Fee Per Gas: ${tx.maxFeePerGas}`)
			console.log(`Gas Limit: ${tx.gasLimit}`)
			console.log(`Value: ${tx.value}`)
			console.log(`Data: ${tx.data.toString('hex')}`)
			console.log(`Access List: ${JSON.stringify(tx.toJSON().accessList)}`)
			
			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r),
				toBuffer(tx.s),
				tx.common.chainId
			)

			break
		case DataType.transaction:
			rlpDecoded = rlp.decode(rlpEncoded).map(item => Buffer.from(item))
			
			txData = {
				nonce: BigInt(`0x${rlpDecoded[0].toString('hex')}`),
				gasPrice: BigInt(`0x${rlpDecoded[1].toString('hex')}`),
				gasLimit: BigInt(`0x${rlpDecoded[2].toString('hex')}`),
				to: `0x${rlpDecoded[3].toString('hex')}`,
				value: BigInt(`0x${rlpDecoded[4].toString('hex')}`),
				data: `0x${rlpDecoded[5].toString('hex')}`,
				chainId: BigInt(`0x${rlpDecoded[6].toString('hex')}`),
      }

			common = new Common({chain: txData.chainId, hardfork: Hardfork.Shanghai})
			tx = Transaction.fromTxData(txData, {common})

			console.log('Legacy transaction detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`To: ${tx.toString()}`)
			console.log(`Gas Price: ${tx.gasPrice}`)
			console.log(`Gas Limit: ${tx.gasLimit}`)
			console.log(`Value: ${tx.value}`)
			console.log(`Data: 0x${tx.data.toString('hex')}`)
			console.log(`Nonce: ${tx.nonce}`)


			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r === '' ? '0x' : tx.r),
				toBuffer(tx.s === '' ? '0x' : tx.s),
				tx.common.chainId()
			)

			break
		case DataType.personalMessage:
			console.log('Personal message detected')
			console.log(`From: ${fromJson.address}`)
			data = Buffer.from(rlp.decode(rlpEncoded))
			console.log(`Message: ${data.toString('utf8')}`)

			signature = sigUtil.personalSign({
				privateKey,
				data,
			})

			break
		case DataType.typedData:
			[version, data] = rlp.decode(rlpEncoded)
			version = Buffer.from(version)
			data = Buffer.from(data)
			version = `V${version.toString('utf8')}`
			data = JSON.parse(data.toString('utf8'))

			console.log('Typed data detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`Version: ${version}`)
			console.log(`Data: ${JSON.stringify(data, null, 2)}`)
			
			signature = sigUtil.signTypedData({
				privateKey,
				data,
				version,
			})

			break
		default:
			throw new Error('Type not supported: ' + ethSignRequest.getDataType())
	}

	privateKey = null	
	const types = ['terminal', 'utf8', 'svg']	
	let ur = (new ETHSignature(Buffer.from(stripHexPrefix(signature), 'hex'), ethSignRequest.getRequestId(), ethSignRequest.getOrigin())).toUREncoder(500)
	let urPart = ur.nextPart()

	types.forEach(type => {
		QRCode.toString(urPart, {type}, (err, str) => {
			if (err) throw new Error(err)
			fs.writeFileSync(`qr.${type}`, Buffer.from(str, 'utf8'))
		})
	})

	// eslint-disable-next-line no-constant-condition
	while (true) {
		QRCode.toString(urPart, {type: "terminal"}, (err, str) => {
			if (err) throw new Error(err)
			console.log(str)
			console.log(urPart)
			require('child_process').spawnSync("read _ ", {shell: true, stdio: [0, 1, 2]});
		})
	}
}

function sleep (ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}

function getFakeDerivePath (address) {
	let addressHash = keccak256(Uint8Array.from(Buffer.from(address, 'hex')))
	return (new CryptoKeypath (
		[0, 1, 2, 3].map(index => new PathComponent({index: addressHash.at(index), hardened:true})))).getPath()
}


