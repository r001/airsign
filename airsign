#!/usr/bin/env node
const QRCode = require('qrcode')
const fs = require('fs')
const inquirer = require('inquirer')
const keythereum = require("keythereum")
const sigUtil = require('@metamask/eth-sig-util')
const {DataType, EthSignRequest, ETHSignature, DataItem, CryptoKeypath, PathComponent} = require('@keystonehq/bc-ur-registry-eth')
const {URDecoder} = require('@ngraveio/bc-ur')
const {Transaction, FeeMarketEIP1559Transaction} = require('@ethereumjs/tx')
const {stripHexPrefix, toBuffer, toRpcSig} = require('@ethereumjs/util')
const {keccak256} = require('ethereum-cryptography/keccak') 
const rlp = require('@ethereumjs/rlp')
const {promisify} = require('es6-promisify')
const readdir = promisify(fs.readdir)

var api
const arg = process.argv[2]

const ai = '/data/data/com.termux/files/home/airsign/'

;(async () => {
try {
	if (!arg) {
		// fixed bug termux hang during loading
		api = require('termux')
	}


	if (arg) {
		try {
			await sign(arg)
		} catch (e) {
			if (!arg.match(/-/)) {
				console.log(`Could not decode.`)
			}
			// `airsign -` called

			let answers = inquirer.prompt([
				{
					type: 'input',
					name: 'qr',
					message: 'Signable:',
					validate (value) {
						try {
							var decoder = new URDecoder()
							needMoreData = decoder.receivePart(value)
							return true
						} catch (e) {
							return 'Should be something like: ur:eth-sign-request/...'
						}
					},
					filter: String,
				}
			])

			await sign(answers.qr)
		}
	} else if (api.hasTermux) {
		var decoder = new URDecoder()
		var needMoreData = true
		var ur

		console.log(`Receiving data from clipboard... (press Ctrl+C to cancel)`)
		while (needMoreData) {
			ur = await api.clipboardGet().run()
			needMoreData = decoder.receivePart(ur)
			await sleep(300)
		}
		var ethSignRequest = EthSignRequest.fromCBOR(decoder.resultUR().decodeCBOR())
		console.log(`Received and decoded request successfully`)

		await sign(ethSignRequest)
	}

	process.exit(0)
} catch (e) {
	console.error(e.stack)
	process.exit(1)
}
})()

async function sign (ethSignRequest) {
	var keyStore = ai + '.ethereum/keystore/'
	let parentFingerprint = Buffer.from('12345678', 'hex')

	let files = await readdir(keyStore) 

	let	fromJson = files
		.map(file => {
			try {
				return JSON.parse(fs.readFileSync(keyStore + file))
			} catch (e) {
				return {address: ''}	
			}
		})
		.find(json => 
			getFakeDerivePath(json.address, parentFingerprint) === 
			ethSignRequest.getDerivationPath()
		)

	if (!fromJson) throw new Error('Address not found for: ' + ethSignRequest.getDerivationPath().toString())

	let answer = await inquirer.prompt([
		{
			type: 'password',
			name: 'pw',
			message: 'Password:',
			mask: '*',
		}
	])

	var privateKey = keythereum.recover(answer.pw, fromJson)
	answer.pw = null
	const EIP_1599_TRANSACTION_TYPE = 2
	const EIP_1599_TRANSACTION_TYPE_BUFFER = Buffer.from(EIP_1599_TRANSACTION_TYPE.toString(16).padStart(2, '0'), 'hex')
	let tx, data, version, type, signature
	let rlpEncoded = ethSignRequest.getSignData()
	let rlpDecoded = rlp.decode(rlpEncoded)

	switch (ethSignRequest.getDataType()) {
		case DataType.typedTransaction:
			type = rlpEncoded.subarray(0, 1)

			if (!type.equals(EIP_1599_TRANSACTION_TYPE_BUFFER)) {
				throw new Error('Unknown transaction type')
			}

			console.log('EIP-1559 transaction detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`To: ${Buffer.from(rlpDecoded[5]).toString('hex')}`)
			console.log(`ChainId: ${Number(Buffer.from(rlpDecoded[0]).toString('hex'))}`)
			console.log(`Nonce: ${Number(Buffer.from(rlpDecoded[1]).toString('hex'))}`)
			console.log(`Max Priority Fee Per Gas: ${BigInt(Buffer.from(rlpDecoded[2]).toString('hex'))}`)
			console.log(`Max Fee Per Gas: ${BigInt(Buffer.from(rlpDecoded[3]).toString('hex'))}`)
			console.log(`Gas Limit: ${BigInt(Buffer.from(rlpDecoded[4]).toString('hex'))}`)
			console.log(`Value: ${BigInt(Buffer.from(rlpDecoded[6]).toString('hex'))}`)
			console.log(`Data: ${Buffer.from(rlpDecoded[7]).toString('hex')}`)
			console.log(`Access List: ${Buffer.from(rlpDecoded[8]).toString('hex')}`)
			
			tx = FeeMarketEIP1559Transaction.fromSerializedTx(rlpEncoded)
			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r === '' ? '0x' : tx.r),
				toBuffer(tx.s === '' ? '0x' : tx.s),
				tx.common.chainId
			)

			break
		case DataType.transaction:

			console.log('Legacy transaction detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`To: ${Buffer.from(rlpDecoded[3]).toString('hex')}`)
			console.log(`Gas Price: ${BigInt(Buffer.from(rlpDecoded[1]).toString('hex'))}`)
			console.log(`Gas Limit: ${BigInt(Buffer.from(rlpDecoded[2]).toString('hex'))}`)
			console.log(`Value: ${BigInt(Buffer.from(rlpDecoded[4]).toString('hex'))}`)
			console.log(`Data: ${Buffer.from(rlpDecoded[5]).toString('hex')}`)
			console.log(`Nonce: ${Number(Buffer.from(rlpDecoded[0]).toString('hex'))}`)

			tx = Transaction.fromSerializedTx(rlpEncoded)

			tx = tx.sign(privateKey)

			signature = toRpcSig(
				tx.v,
				toBuffer(tx.r === '' ? '0x' : tx.r),
				toBuffer(tx.s === '' ? '0x' : tx.s),
				tx.common.chainId
			)

			break
		case DataType.personalMessage:
			console.log('Personal message detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`Message: ${Buffer.from(rlp.decode(ethSignRequest.getSignData())).toString('utf8')}`)

			signature = sigUtil.personalSign({
				privateKey,
				data: '0x' + stripHexPrefix(ethSignRequest.getSignData().toString('hex')),
			})

			break
		case DataType.typedData:
			[version, data] = rlp.decode(ethSignRequest.getSignData())
			version = `V${Buffer.from(version, 'hex').toString('utf8')}`
			data = JSON.parse(Buffer.from(data, 'hex').toString('utf8'))

			console.log('Typed data detected')
			console.log(`From: ${fromJson.address}`)
			console.log(`Version: ${version}`)
			console.log(`Data: ${JSON.stringify(data, null, 2)}`)
			
			signature = sigUtil.signTypedData({
				privateKey,
				data,
				version,
			})

			break
		default:
			throw new Error('Type not supported: ' + ethSignRequest.getDataType())
	}

	privateKey = null	
	const types = ['terminal', 'utf8', 'svg']	
	let ur = ETHSignature.fromDataItem(new DataItem(signature)).toUREncoder(500)
	let urPart = ur.nextPart()

	types.forEach(type => {
		QRCode.toString(urPart, {type}, (err, str) => {
			if (err) throw new Error(err)
			fs.writeFileSync(`qr.${type}`, Buffer.from(str))
		})
	})

	// eslint-disable-next-line no-constant-condition
	while (true) {
		QRCode.toString(urPart, {terminal: "terminal"}, (err, str) => {
			if (err) throw new Error(err)
			console.log(str)
			console.log(urPart)
			require('child_process').spawnSync("read _ ", {shell: true, stdio: [0, 1, 2]});
		})
	}
}

function sleep (ms) {
	return new Promise(resolve => setTimeout(resolve, ms))
}

function getFakeDerivePath (address, parentFingerprintBuffer) {
	let addressHash = keccak256(Uint8Array.from(Buffer.from(address, 'hex')))
	return (new CryptoKeypath (
		[0, 1, 2, 3].map(index => new PathComponent({index: addressHash[index], hardened:true})),
		parentFingerprintBuffer
	)).getPath()
}


