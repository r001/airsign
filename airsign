#!/usr/bin/env node
var api
if (!process.argv[2]) {
	api = require('termux')
}
const decode = require('qr-encoding').decode
const ethUtil = require('ethereumjs-util')
const fs = require('fs')
const QRCode = require('qrcode')
const sigUtil = require('@metamask/eth-sig-util')
const Tx = require('@ethereumjs/tx')
const keythereum = require("keythereum")
const inquirer = require('inquirer')

const ai = '/data/data/com.termux/files/home/airsign/'

if (process.argv[2]) {
	try {
		sign(process.argv[2])
	} catch (e) {
		if (!process.argv[2].match(/-/)) {
			console.log(`Could not decode.`)
		}

		inquirer.prompt([
			{
				type: 'input',
				name: 'qr',
				message: 'Signable:',
				validate (value) {
					try {
						decode(value)
						return true
					} catch (e) {
						return 'Should be something like: eths:/?t=001011....'
					}
				},
				filter: String,
			}
		]).then((answers) => {
			sign(answers.qr)
		})

	}
} else if (api.hasTermux) {
	api.clipboardGet()
		.run()
		.then(sign)
}

function sign (text) {
	text = text.replace(/^\\s*/, '').replace(/\\s*$/, '')
	var sigParams = decode(text)
	var fromJson, signature, rawTx, tx
	var keyStore = ai + '.ethereum/keystore/'
	var re = new RegExp(sigParams.from_part.toLowerCase())

	fs.readdir(keyStore, (err, files) => {
		if (err) {
			throw new Error(err.stack);
		}

		fromJson = files
			.map(file => {
				try {
					return JSON.parse(file)
				} catch (e) {
					return {address: null}	
				}
			})
			.find(json => 
				json.address
				.replace(/^/, '0x')
				.toLowerCase()
				.match(re)
			)

		if (!fromJson) throw new Error('Address not found for: ' + sigParams.from_part)

		inquirer.prompt([
			{
				type: 'password',
				name: 'pw',
				message: 'Password:',
			}
		]).then( (answer) => {
			var privateKey = keythereum.recover(answer.pw, fromJson)
			answer.pw = null

			switch (sigParams.type) {
				case 'sign_transaction':
					rawTx = {
						from: '0x' + ethUtil.stripHexPrefix(fromJson.address),
						to: sigParams.payload.to,
						gasPrice: sigParams.payload.gasPrice,
						gasLimit: sigParams.payload.gasLimit,
						chainId: sigParams.payload.chainId,
						nonce: sigParams.payload.nonce,
						value: sigParams.payload.value,
						data: sigParams.payload.data,
					}

					tx = new Tx(rawTx)
					tx.sign(privateKey)
					signature = ethUtil.toRpcSig(tx.v, tx.r, tx.s, rawTx.chainId)
					break
				case 'sign_message':
					signature = sigUtil.personalSign({
						privateKey,
						data: '0x' + ethUtil.stripHexPrefix(sigParams.payload),
					})

					break
				case 'sign_personal_message':
					signature = sigUtil.personalSign({
						privateKey,
						data: '0x' + ethUtil.stripHexPrefix(sigParams.payload),
					})

					break
				case 'sign_typed_data':
					signature = sigUtil.signTypedData({
						privateKey,
						data: '0x' + ethUtil.stripHexPrefix(sigParams.payload),
						version: sigParams.version,
					})

					break
				default:
					throw new Error('Not supported: ' + sigParams.type)
			}
			privateKey = null	

			QRCode.toString(signature, {type: 'terminal'}, (err, str) => {
				if (err) throw new Error(err)
				console.log(str)
			})
		})	
			.catch((error) => {
				throw new Error( `Inquirer failure: ${error.message}`)
			})
	})
}
